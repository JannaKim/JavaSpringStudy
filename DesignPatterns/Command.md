# Command Pattern
### 1.정의
- 특정 객체애 대한 커맨드를 객체화하여 해당 커맨드 객체를 필요에 따라 처리하는 패턴이다.
- 보통 주체객체와 대상객체가 존재하고, 대상객체에 대한 행동은 주체개체에서 메소드로 처리하는데, 이 행동을 객체로 만들어서 처리하는 경우가 커맨드패턴.
- 커맨드 발생시점을 사용자가 커스터마이징 해야 하는 경우에 사용
- 여러 커맨드를 조합하여 하나의 커맨드로 사용해야 하는 경우에 사용
- 커맨드 udno,redo를 구현해야 할 경우


장점<br>
- 작업을 수행하는 객체와 요청하는 객체를 분리하기에 SRP원칙을 지켜낸다.
- 기존 코드 수정없이 새로운 수행객체, 명령어 들의 추가가 가능하기 때문에 OCP원칙을 지켜낸다.
- 커맨드 단위의 별도 애선(undo,redo)가 가능하다
- 커맨드 상속 및 조합으로 정교한 커맨드 구현이 가능하다.

단점<br>
- 평소와 다르게 행동이 객체로 분리되어 이해가 어렵고 복잡한 설계구조를 가진다.

### 2.구조
![command_Structure](./img/command_structure.pngd)


- Client : 명령을 내릴 사용자<br>
- Recevier : Client의 요청을 수행할 객체, 행동(action)을 구현
- Invoker : Cinet의 요청을 Reciever에게 전달해 행동을 호출하는 객체, 여기서 요청에 대한 설정을 한다.

### 3.예시
> 전등과 음악 플레이어 통합 리모콘
- 전등과 음악 플레이어를 모두 on/off하는 명령을 하나의 리모콘에 담고 싶을때
- on/off는 명령어로서 각각 객체가 된다.
- on/off 명령은 리모콘(Invoker)에 등록되어 사용된다.
- 추가하고 싶은 명령어는 새 객체를 만들고 리모콘(Invoker)에 추가하면 된다.

#### 4.SingleResponsibility Principle (단일 책임 원칙)
- 한 클래스는 하나의 책임만 가져야 한다.
#### 5.Open/Closed Principle (개방-폐쇄 원칙)
- 소프트웨어 요소는 확장에 열려있으나 변경에는 닫혀 있어야 한다.

